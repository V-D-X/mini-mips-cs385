// Behavioral model of MIPS - single cycle implementation, R-types and addi
module reg_file (RR1,RR2,WR,WD,RegWrite,RD1,RD2,clock);
  input [1:0] RR1,RR2,WR;   // Adaptations for 16-bit CPU
  input [15:0] WD;
  input RegWrite,clock;
  output [15:0] RD1,RD2;

  reg [15:0] Regs[0:3];

  assign RD1 = Regs[RR1];
  assign RD2 = Regs[RR2];

  initial Regs[0] = 0;

  always @(negedge clock)
    if (RegWrite==1 & WR!=0) 
      Regs[WR] <= WD;
      
endmodule

module alu (ALUctl,A,B,ALUOut,Zero); // this needs to be gate level
  input [3:0] ALUctl;
  input [15:0] A,B;
  output reg [15:0] ALUOut;
  output Zero;
  always @(ALUctl, A, B) // reevaluate if these change
    case (ALUctl)
      4'b0000: ALUOut <= A & B;
      4'b0001: ALUOut <= A | B;
      4'b0010: ALUOut <= A + B;
      4'b0110: ALUOut <= A - B;
      4'b0111: ALUOut <= A < B ? 1:0;
      4'b1100: ALUOut <= ~A & ~B;
      4'b1101: ALUOut <= ~A | ~B;
    endcase
  assign Zero = (ALUOut==0); // Zero is true if ALUOut is 0. Not used for now, but keep for future CPU development
endmodule

module MainControl (Op,Control);                // this is the code representation of the table on the board; we must implement the whole thing
  input [3:0] Op;                               // indicated by arrow down on top of table
  output reg [6:0] Control;                     // indicated by arrow up on top of table
// Control bits: RegDst,ALUSrc,RegWrite,ALUctl  // use ALUctl directly for our simplified CPU model
  always @(Op) case (Op)                        // writing a line for each instruction in the table. TODO: how did he make the table? tied to how ALU works
    4'b0000: Control <= 7'b101_0010;          // add instruction; 7 for 7 bits in output. underscores are ignored by verilog. do rest of R-types in this format
    4'b0111: Control <= 7'b011_0010;          // addi
  endcase
endmodule

module ALUControl (ALUOp,FuncCode,ALUCtl);      // we don't use this in our simplified mips cpu, since we don't have a funct field
  input [1:0] ALUOp;
  input [5:0] FuncCode;
  output reg [3:0] ALUCtl;
  always @(ALUOp,FuncCode) case (ALUOp)
    2'b00: ALUCtl <= 4'b0010; // add
    2'b01: ALUCtl <= 4'b0110; // subtract
    2'b10: case (FuncCode)
       32: ALUCtl <= 4'b0010; // add
       34: ALUCtl <= 4'b0110; // sub
       36: ALUCtl <= 4'b0000; // and
       37: ALUCtl <= 4'b0001; // or
       39: ALUCtl <= 4'b1100; // nor
       42: ALUCtl <= 4'b0111; // slt
    endcase
  endcase
endmodule

module CPU (clock,PC,ALUOut,IR);
  input clock;
  output [15:0] ALUOut,IR,PC;
  reg[15:0] PC;
  reg[15:0] IMemory[0:1023];
  wire [15:0] IR,NextPC,A,B,ALUOut,RD2,SignExtend;
  wire [3:0] ALUctl;
  wire [1:0] WR; 
// Test Program
  initial begin 
    // IMemory[0] = 16'b0111_00_01_00001111;  // addi $t1, $0,  15   ($t1=15). This is literally the addi instruction itself
    IMemory[1] = 32'h200a0007;  // addi $t2, $0,  7    ($t2=7)    // 16-bit MIPS version

    // IMemory[2] = 32'h012a5824;  // and  $t3, $t1, $t2  ($t3=7) 
    // IMemory[2] = 16'b0000_01_10_11  // 16-bit MIPS version

    IMemory[3] = 32'h012b5022;  // sub  $t2, $t1, $t3  ($t2=8)
    IMemory[4] = 32'h014b5025;  // or   $t2, $t2, $t3  ($t2=15)
    IMemory[5] = 32'h014b5820;  // add  $t3, $t2, $t3  ($t3=22)
    IMemory[6] = 32'h014b4827;  // nor  $t1, $t2, $t3  ($t1=-32)
    IMemory[7] = 32'h016a482a;  // slt  $t1, $t3, $t2  ($t1=0)
    IMemory[8] = 32'h014b482a;  // slt  $t1, $t2, $t3  ($t1=1)
  end
  initial PC = 0;
  assign IR = IMemory[PC>>1];               // again, usually 2, but 1 because simp has 2-byte words instead of 4-byte
  assign WR = (RegDst) ? IR[7:6]: IR[9:8];  // RegDst Mux
  assign B  = (ALUSrc) ? SignExtend: RD2;   // ALUSrc Mux 
  assign SignExtend = {{8{IR[7]}},IR[7:0]}; // sign extension unit - first 8 bytes are the sign of IR[7], concatenate these together for 16-bit output to ALU
  reg_file rf (IR[11:10],IR[9:8],WR,ALUOut,RegWrite,A,RD2,clock);
  alu fetch (4'b0010,PC,16'd2,NextPC,Unused);  // 2 because our simple CPU has 2-byte words
  alu ex (ALUctl, A, B, ALUOut, Zero);
  MainControl MainCtr (IR[15:12],{RegDst,ALUSrc,RegWrite,ALUctl}); // get directly from ALU since we got rid of the funct field thing
  always @(negedge clock) begin 
    PC <= NextPC;
  end
endmodule

// Test module
module test ();
  reg clock;
  wire signed [15:0] WD,IR,PC;
  CPU test_cpu(clock,PC,WD,IR);
  always #1 clock = ~clock;
  initial begin
    $display ("Clock PC   IR                                 WD");
    $monitor ("%b     %2d   %b  %3d (%b)",clock,PC,IR,WD,WD);
    clock = 1;
    #16 $finish;
  end
endmodule

/* Output
Clock PC   IR                                 WD
1      0   00100000000010010000000000001111   15 (00000000000000000000000000001111)
0      4   00100000000010100000000000000111    7 (00000000000000000000000000000111)
1      4   00100000000010100000000000000111    7 (00000000000000000000000000000111)
0      8   00000001001010100101100000100100    7 (00000000000000000000000000000111)
1      8   00000001001010100101100000100100    7 (00000000000000000000000000000111)
0     12   00000001001010110101000000100010    8 (00000000000000000000000000001000)
1     12   00000001001010110101000000100010    8 (00000000000000000000000000001000)
0     16   00000001010010110101000000100101   15 (00000000000000000000000000001111)
1     16   00000001010010110101000000100101   15 (00000000000000000000000000001111)
0     20   00000001010010110101100000100000   22 (00000000000000000000000000010110)
1     20   00000001010010110101100000100000   22 (00000000000000000000000000010110)
0     24   00000001010010110100100000100111  -32 (11111111111111111111111111100000)
1     24   00000001010010110100100000100111  -32 (11111111111111111111111111100000)
0     28   00000001011010100100100000101010    0 (00000000000000000000000000000000)
1     28   00000001011010100100100000101010    0 (00000000000000000000000000000000)
0     32   00000001010010110100100000101010    1 (00000000000000000000000000000001)
1     32   00000001010010110100100000101010    1 (00000000000000000000000000000001)
*/